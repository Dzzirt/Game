
            СТРУКТУРЫ И АЛГОРИТМЫ ОБРАБОТКИ ДАННЫХ


A
   Дан комплекс вопросов, связанных с выполнением лабораторных
работ по дисциплине "Структуры и алгоритмы обработки  данных в
ЭВМ".  Определены цели и содержание работы, приведены варианты
заданий,  разобраны  примеры  программ,   ориентированных   на
применение различных структур данных.


               1. СОДЕРЖАНИЕ ЛАБОРАТОРНЫХ РАБОТ

   В течение  семестра  студенты выполняют  пять  лабораторных
работ:  "Текстовые  файлы",   "Линейные  списки",   "Деревья",
"Графы",  "Поиск  и  сортировка  данных",  ориентированные  на
применение  основных  структур данных.
   Выполнение лабораторных   работ   включает   этапы   выбора
структуры   данных,   алгоритмизации   задачи,    составления,
тестирования и отладки программы. Методические рекомендации по
всем зтим этапам приведены в [1-3,7].
   Определение, способы  представления   и  примеры применения
указанных структур данных приведены в [3-6].


          2. ВАРИАНТЫ ЗАДАНИЙ ДЛЯ ЛАБОРАТОРНЫХ РАБОТ

                     2.1. Текстовые файлы

   Общими требованиями к лабораторной работе являются:
   1) указывать  имена входного  и  выходного   файлов   через
командную строку или с клавиатуры в процессе работы программы;
   2) обрабатывать ошибки открытия файлов;
   3) не  использовать  стандартные функции работы со строками
(типа COPY, POS из ПАСКАЛя);
   4) не переписывать файл в оперативную память целиком.

   1. Имеется   текстовый   файл.    Разработать    программу,
обеспечивающую   вставку   запятой  перед  словами  "который",
"которая",  "которое",  "которые", если они не являются первым
словом предложения (6).

   2. Текстовый файл содержит последовательность  целых чисел,
разделенных  произвольным  количеством других символов.  Числа
могут переходить со строки на строку.  Требуется  найти  сумму
чисел (6).

   3. Имеется текстовый файл с некоторым  описанием.  Переносы
слов   разрешены.   Выдать   информацию  о  том,  сколько  раз
встречается в тексте каждое слово (6).

   4. Каждая   строка   текстового   файла   имеет   следующую
структуру:
         -------------------------------------------
         ¦ Фамилия  ¦ Факультет ¦ Группа ¦ Средний ¦
         ¦ студента ¦           ¦        ¦ балл    ¦
         -------------------------------------------
   Поля разделены одним или несколькими пробелами. Внутри поля
пробелы не допускаются.  Требуется организовать текстовый файл
с полями
             ------------------------------------
             ¦ Факультет ¦ Группа ¦ Средний балл¦
             ¦           ¦        ¦ по группе   ¦
             ------------------------------------
и определить  группы с наибольшим и наименьшим средним  баллом
(6).

   5. Задан текстовый файл.  Переносов слов нет. Создать новый
файл, в котором каждое слово будет записано в обратном порядке
(6).

   6. Дан текстовый файл и ключевое слово для  поиска.  Выдать
на  экран 5 строк файла,  начиная с первой строки,  включающей
заданное  слово.  Выделить   ключевое   слово   курсором   или
подсветкой (6).

   7. Дан текстовый файл и  два  слова.  Переносов  слов  нет.
Получить  новый  файл,  в  котором все вхождения первого слова
заменены на второе слово (6).

   8. Имеется два текстовых файла.  В первом из них содержится
некоторое описание.  Переносы слов  допускаются.  Второй  файл
содержит  список  слов,  не подлежащих разглашению.  Требуется
переписать  первый  файл,  заменив  каждое  из  подобных  слов
точками (6).

   9. Имеется  текстовый  файл  с  некоторым  описанием.   Все
предложения   заканчиваются   точкой.   Требуется   проверить,
является  ли  первая  буква  каждого  предложения   прописной.
Исправить обнаруженные ошибки (6).

   10. Имеется текстовый файл с некоторым описанием. Переносов
слов нет.  Требуется каждые 3 предложения выделить в отдельный
абзац.  Каждое   предложение   может   заканчиваться   точкой,
вопросительным либо восклицательным знаком (6).

   11. Некоторый   текст   состоит   из   нескольких   частей,
записанных  в  отдельных  файлах.  Имена  этих  файлов и общий
заголовок текста указаны в отдельном  файле.  Создать  файл  с
полным  текстом.  Заголовок должен содержаться в центре первой
строки (6).

   12. В   текстовом   файле   специальные   термины  выделены
кавычками.  Переписать  файл  так,  чтобы  термины  выделялись
прописными буквами (6).

   13. Имеется текстовый файл,  в котором специальные  термины
выделены   прописнами  буквами.  Переписать  файл  так,  чтобы
термины были набраны строчными буквами в кавычках (6).

   14. Имеется   текст   документа,  состоящий  из  нескольких
параграфов.  Каждый параграф начинается с заголовка и  отделен
пустой  строкой  от  предыдущего параграфа.  Текст разделен на
страницы.  Номер страницы проставлен в ее начале и  выделен  с
обеих  сторон  знаком  '-'.  Сформировать  файл  с оглавлением
документа (7).

   15. В некоторых строках текстового файла имеются выражения,
состоящие   из   двух   целых   чисел,   разделенных    знаком
арифметической   операции('+','-','*','/').   В  строке  перед
выражением и после него могут находиться произвольные символы.
Требуется   выделить  строку,  в  которой  значение  выражения
максимально (7).

   16. Дан   текстовый   файл.   Произвести  его  шифрацию  по
следующим правилам:
     1) символы с кодами 1-31,243-255 не менять,  т.К. Они мо-
гут играть роль служебных;
     2) шифровать текст блоками по 32 байта;
     3) коды символов 32-242 зашифровать по формулам
            a[n]=((243-n+m) mod 211)+32
            m=(3*k-1) mod 99               , где
        n-исходный код символа;
        a[n]-зашифрованный код;
        k-порядковый номер блока.
     Как произвести дешифрацию текста (7)?

   17. Придумать систему шифрации  текста.  Символы  с  кодами
1-31,243-255 не менять,  т.К. Они могут играть роль служебных.
Написать программу шифрации-дешифрации текстового файла (7).

   18. В  файле  записан  текст  стихотворения.  Форматировать
текст так,  чтобы каждый куплет из 4 строк следовал с одной  и
той  же  позиции,  начинался  с  прописной буквы и был сдвинут
относительно предыдущего куплета на 5 позиций вправо или влево
поочередно (7).

   19. Имеется файл с текстом на русском языке  без  переносов
слов.  Дать все варианты переноса всех слов текста.  Например,
все варианты  переноса  слова "барабан"  можно представить как
ба-р-а-б-ан. Перенос возможен по следующим правилам:
   1) переносится  либо  остается в конце строки не менее двух
символов;
   2) невозможен перенос перед буквами 'ь' и 'ъ';
   3) слово должно иметь не менее двух слогов;
   4) в  оставшейся  и  переносимой  частях  слова должны быть
гласные буквы (8).

   20. Составить программу перевода чисел в форме  константы с
плавающей точкой в строковый формат (8).

   21. Строки текстового  файла  содержат  фамилии  студентов.
Определить   порядковый   номер   байта,  начиная  с  которого
располагается первая  по  алфавиту  фамилия.  Заменить  данную
фамилию  в исходном файле символами '*',  не переписывая этого
файла (8).

   22. В  текстовом  файле записан отдельный абзац.  Переносов
слов нет.  Выровнять строки абзаца по ширине.  Иными  словами,
правые границы строк выравниваются по заданной позиции за счет
вставки дополнительных пробелов между словами.  Первая  строка
абзаца должна иметь заданный отступ, а остальные строки должны
начинаться  с  первой  позиции.  Последняя  строка  абзаца  по
правому  краю  не  выравнивается.  Число  строк  в  исходном и
конечном файлах может отличаться (8).

   23. Разработать программу перекодировки текстового файла из
одной системы кодировки в другую и обратно.  Система кодировки
должна содержаться в отдельном файле (8).

   24. В текстовом файле записан  отдельный  абзац.  Некоторые
слова перенесены со строки на следующую строку.  Знак переноса
'-'.  Выровнять строки абзаца по ширине. Иными словами, правые
границы  строк  выравниваются  по  заданной  позиции  за  счет
вставки дополнительных пробелов между словами.  Первая  строка
абзаца должна иметь заданный отступ, а остальные строки должны
начинаться  с  первой  позиции.  Последняя  строка  абзаца  по
правому  краю  не  выравнивается.  Число  строк  в  исходном и
конечном файлах может отличаться (9).

   25. Задан  текстовый  файл. Каждая строка содержит не более 
255 символов. Создать  новый  файл,  в  котором  строки  будут
следовать в обратном порядке. Размер файла  не  ограничивается
(9).

                    2.2. Линейные списки

   Общими требованиями к лабораторной работе являются:
   1) организовать  ввод  данных  из  файла  в   понятной  для 
пользователя форме;
   2) обеспечить   возможность   многократных   запросов   без
повторного запуска программы.

   1. Автомобильная  стоянка  вмещает  N  машин  и  имеет одну
полосу с единственным въездом-выездом.  Если владелец приходит
за  машиной,  временно  выезжают и потом возвращаются в том же
порядке  все  машины,  загораживающие  проезд.  Если   стоянка
заполнена,     то    прибывшая    машина    уезжает.    Задана
последовательность номеров машин  с  признаками  прибытия  или
убытия.  Составить  протокол работы стоянки,  сообщая обо всех
событиях (6).

   2. Автостоянка содержит одну полосу,  на которой может быть
размещено до N машин.  Имеется план прибытия и убытия машин на
стоянку.  Если  в момент прибытия стоянка оказывается занятой,
машина уезжает восвояси.  Машины въезжают с южной  стороны,  а
могут  выехать  из K (K<N) крайних мест северной стороны.  При
выезде машины очередь сдвигается с юга на север. Требуется:
   1) промоделировать работу стоянки,  последовательно сообщая
о приходе и  убытии  машин  с  выдачей  информации  о  стоящих
машинах;
   2) выдать два списка номеров машин:  тех, которые не смогли
встать на стоянку, и тех, что не смогли выехать вовремя (6).

   3. Составить  программу  работы  с  циклической   очередью,
организованной   с   помощью   массива.   Обеспечить  операции
постановки в очередь,  продвижения очереди, вставки в середину
после элемента с заданным ключом и удаления из середины (6).

   4. Задания  для   выполнения  на компьютере имеют различные
приоритеты, задаваемые цифрами от 1 до 5 (5-высший приоритет).
Для каждого приоритета образуется отдельная очередь. Приоритет
задания  может  меняться.  При  повышении  приоритета  задание
помещается в конец другой очереди, а при понижении - в начало.
Составить программу, обеспечивающую:
   1) выдачу общей очереди;
   2) выдачу очереди заданного приоритета;
   3) перестройку очередей при изменении приоритета (6).

   5. Перед открытием двух железнодорожных касс сформировались
2 очереди пассажиров,  причем некоторые из них находятся сразу
в  обеих очередях.  Для каждого пассажира известны его места в
очередях и необходимое время обслуживания.  Если у какого-либо
пассажира очереди подходят одновременно, то он обслуживается в
первой   кассе.   Промоделировать   работу    касс,    выдавая
последовательно информацию об обслуживании пассажиров (7).

   6. Два стека размещены в одном массиве и  растут  навстречу
друг  другу.  Задана  последовательность операций размещения и
удаления  элементов  с  указанием  номера  стека.   Обеспечить
выполнение  данных  операций  и  обработку аварийных ситуаций.
Сообщить в конце:
   1) какой  минимальный  резерв  памяти оставался в массиве в
процессе выполнения операций;
   2) какой  интервал  индексов  массива  не использовался для
размещения элементов (6).

   7. Две очереди размещены в одном массиве и растут навстречу
друг другу.  Задана последовательность операций  размещения  и
удаления  элементов  с  указанием  номера очереди.  Обеспечить
выполнение данных операций  и  обработку  аварийных  ситуаций.
Сообщить в конце:
   1) какой минимальный резерв памяти оставался  в  массиве  в
процессе выполнения операций;
   2) какой интервал индексов  массива  не  использовался  для
размещения элементов (6).

   8. Выборы  старосты  в  группе  студентов  из   M   человек
организованы  по следующим правилам.  Задаются целые числа N и
K.  Студенты становятся по  кругу  в  соответствии  со  своими
номерами в журнале. Начиная от N-го студента отсчитывается K-й
студент.  Счет ведется циклически по возрастанию номеров. Этот
студент   выбывает  из  претендентов.  Начиная  со  следующего
студента,  процедура повторяется. Последний оставшийся студент
становится старостой.  Ввести значения M,  N,  K и найти номер
старосты (7).

   9. В   символьной  строке  записано  выражение  из  букв  и
операций в постфиксной форме (знак операции  после операндов).
Проверить   правильность   записи   и  перевести  выражение  в
инфиксную (обычную)  форму  со  скобками. Например,  выражение
(a+b)*c-d*e  записывается  в постфиксной форме как  ab+c*de*-.
Требуется выдать его в виде (((a+b)*c)-(d*e)) (7).

   10. В  символьной  строке  записано  выражение  из  букв  и
операций в префиксной форме (знак операции  перед операндами).
Проверить   правильность   записи   и  перевести  выражение  в
постфиксную форму (знак операции после операндов). При наличии 
ошибок указать место первой из них.
   Пример: выражение  (a+b)*c-d*e  записывается  в  префиксной
форме как -*+abc*de. Требуется выдать его в виде ab+c*de*-(7).

   11. В  символьной  строке  записано  выражение  из  цифр  и
операций в постфиксной форме (знак операции  после операндов).
Проверить правильность записи и найти значение  выражения. При 
наличии ошибок указать место первой из них.
   Пример: выражение (2+3)*4-5*6  записывается  в  постфиксной
форме как 23+4*56*- (7).

   12. В   некотором   институте   приобретаемые    компьютеры
выделяются   различным   факультетам  поочередно.  В  пределах
факультетов имеются очереди из кафедр.  Факультет,  получивший
компьютер,  перемещается  в  конец очереди,  а соответствующая
кафедра   исключается   из   факультетской   очереди.    Вновь
организованные факультеты и кафедры занимают последние места в
соответствующих очередях.  Составить программу ведения очереди
на компьютеры (8).

   13. Данные  о  студенческих  группах  записаны  в  файле  в
следующем виде:
              ----------------------------------
              ¦ Информация ¦  Факультет ¦ Курс ¦
              ¦ о группе   ¦            ¦      ¦
              ----------------------------------
   Организовать с  помощью  указателей  размещение  списка   с
данными о группах в основной памяти так,  чтобы каждый элемент
располагался один раз.  Составить программу выдачи всех  групп
заданного  факультета  либо  заданного курса без перебора всех
элементов (8).

   14. Имеются   N   линейных   списков,   имеющих  одинаковую
структуру и упорядоченных по возрастанию  некоторого ключевого
поля. Создать общий упорядоченный список, используя  имеющуюся
частичную сортировку (8).

   15. Трассировка  программы,   не   содержащей   рекурсивных
вызовов  и  повторяющихся  имен  процедур,  распечатана в виде
списка выполняемых процедур. Процедура попадает в список, если
к ней произошло обращение из вызывающей процедуры либо возврат
управления из  вызванной  ей  процедуры.  Структура  программы
такова,  что  каждая вызываемая процедура вложена в вызывающую
ее процедуру.  Известен объем памяти,  который  требуется  для
загрузки каждой процедуры.  При выходе из процедуры занимаемая
ей   память   освобождается.   Выяснить,   соответствует    ли
трассировка  правильной  работе  программы.  Определить размер
памяти,  необходимый для работы программы,  и цепочку вызовов,
требующую максимальной памяти (8).

   16. У множества шпионов,  собравшихся вместе для наблюдения
секретного     объекта,    имеется    единственный    бинокль.
Сформировалась очередь на этот  бинокль.  Для  каждого  шпиона
задан   период   наблюдения   в  минутах  и  предельное  время
нахождения в очереди. После наблюдения каждый шпион становится
снова  в  конец  очереди.  Как  только  для какого-либо шпиона
истекает предельное время нахождения в очереди, он покидает ее
(даже  если  в  этот момент владеет биноклем) и отправляется к
резиденту. Вывести протокол наблюдения шпионов за объектом(9).

   17. На   узловой   станции  необходимо  менять  направления
движения всех  поездов.  Для  этого  предназначен  специальный
тупик.  Зашедший  в  тупик  последний  поезд  выходит  из него
первым.  Известны  моменты  прихода   поездов   и   минимально
необходимое   время   стоянки (одинаковое  для всех  поездов).
Требуется:
   1) составить расписание стоянки поездов на станции с учетом
смены направления движения;
   2) поменять   между   собой   моменты   прихода   скорых  и
пассажирских  поездов   так,   чтобы   скорые   поезда   имели
минимальное суммарное время простоя в тупике (9).

   18. Организовать  в  основной  памяти с помощью указателей
стек из очередей. Обеспечить   операции   ведения  очереди из
вершины   стека,   расширения   и  сокращения  стека,  выдачи 
содержимого стека (9).

   19. Организовать  в основной  памяти  с помощью указателей
очередь  из  стеков. Обеспечить  операции  ведения  стека  из
начала  очереди, дополнения  и  продвижения  очереди,  выдачи
содержимого очереди (9).

   20. Текст программы на бейсике включает циклы вида
#  FOR ID=
 ...............
 ...............
#  NEXT  ID  ,
где #-числовой номер(метка); ID-идентификатор параметра цикла.
Требуется:
   1) проверить   правильность    идентификаторов,    задающих
параметры  циклов (не более двух символов;  первый - латинская
буква, а второй, если он имеется, - цифра);
   2) с   помощью  стека  проверить  правильность  вложенности
циклов;
   3) переписать файл с исходным текстом так,  чтобы операторы
цикла каждого последующего уровня вложения  были  сдвинуты  на
две позиции вправо по сравнению с предыдущим уровнем (9).

   21. Учебный план включает перечень дисциплин.  Задан список
пар   дисциплин.   Отдельная   пара   показывает,  что  вторая
дисциплина должна изучаться  после  первой.  Составить  список
дисциплин учебного плана в порядке их изучения.  В том случае,
когда задание некорректно,  т.Е.  В списке пар имеются  циклы,
выдать хотя бы один из них (10).

   22. На  плоскости  расположена  система  из  N  шестеренок,
которая  приводится  в  движение  вращением  шестеренки  1  по
часовой стрелке.  Сцепленные шестеренки могут вращаться только
в    противоположных    направлениях.   Требуется   определить
направление движения каждой шестеренки  либо  установить,  что
систему   заклинит.   Некоторые   шестеренки   могут  остаться
неподвижными (10).

   23. В   некотором   компиляторе   ПАСКАЛя  текст  программы
включает примечания,  выделенные  фигурными  скобками  '{','}'
либо  парами  символов  '(*'  и  '*)'.  Примечания  могут быть
вложенными друг в друга.  Если примечание открыто знаком  '{',
то оно должно быть закрыто знаком '}'.  Аналогично примечание,
начинающееся с символов '(*'  должно  заканчиваться  символами
'*)'. Требуется:
   1) проверить правильность вложенности примечаний;
   2) переписать   файл   с   исходным   текстом   так,  чтобы
отсутствовала  вложенность  комментариев  при  сохранении   их
содержания  и  в  качестве  ограничивающих  символов  остались
только  фигурные  скобки.   Учесть   случай,   когда   символы
примечаний находятся в апострофах (10).

   24. Программа  на ПАСКАЛЕ включает такие сочетания ключевых
слов,  как  REPEAT..UNTIL  и   BEGIN..END.   Некоторые   части
программы  могут быть закомментированы,  а другая часть текста
может представлять из себя константы в  апострофах.  Требуется
проверить правильность вложенности данных конструкций с учетом
допустимости взаимных вложений (11).

   25. Программа на ПАСКАЛЕ включает такие  сочетания ключевых
слов,    как    REPEAT..UNTIL,   IF..THEN..ELSE,   BEGIN..END,
RECORD..END. Конец оператора  определяется  точкой  с  запятой 
(";").  Требуется  проверить  правильность  вложенности данных
конструкций с учетом допустимости взаимных вложений (12).

                         2.3. Деревья

   Общими требованиями к лабораторной работе являются:
   1) вводить   исходное   дерево  из  файла  в  понятной  для
пользователя форме, а не с клавиатуры;
   2) обрабатывать  дерево  в  оперативной памяти,  а не путем
многократного обращения к файлу;
   3) обеспечить   возможность   многократных   запросов   без
повторного запуска программы.

   1. Изделие задано  с  помощью  дерева.  В  листьях  указаны
значения  массы  соответствующих деталей.  Масса сборного узла
определяется как сумма масс составляющих деталей. Требуется:
   1) обеспечить корректировку дерева в режиме диалога;
   2) рассчитать массу всего изделия;
   3) организовать  обход  листьев,  запрашивая новые значения
массы и сообщая, как при этом меняется масса изделия (8).

   2. Ввести  произвольное  сильно  ветвящееся дерево.  Выдать
списки вершин:
   1) являющихся листьями;
   2) не являющихся листьями;
   3) родителей листьев;
   4) заданного уровня, считая от вершины (8).

   3. В    листьях    дерева,    соответствующего    некоторой
конструкции,  указаны  минимально  возможные  значения  массы.
Задана   предельно  допустимая  масса  конструкции.  Требуется
определить максимально возможное  значение  массы  для  каждой
вершины дерева (8).

   4. В    листьях    дерева,    соответствующего    некоторой
конструкции,  указаны  значения  массы.  Масса  сборного  узла
определяется как сумма масс  составляющих  деталей.  Требуется
определить  значение  массы  для каждого узла конструкции,  не
превосходящего заданного уровня от вершины дерева (9).

   5. Имеется дерево, корень которого соответствует основателю
рода.  Сыновья  каждой  вершины  задают  сыновей   и   дочерей
соответствующего    человека.   Указывается   имя   некоторого
человека.  Требуется выдать имена его детей,  внуков, сестер и
братьев, одного из родителей, дедушки или бабушки (9).

   6. Имеются  две  статьи.  Каждая  из  них  включает  список
источников.  В  них в свою очередь могут быть ссылки на другие
источники.  Известны год и месяц опубликования каждой  статьи.
Проверить  корректность  ввода  информации.  Определить  общие
источники двух статей, начиная с заданного года (9).

   7. Структура  некоторого института задана деревом. Сыновьям
корневой вершины соответствуют факультеты,  факультеты в  свою
очередь  делятся  на  кафедры,  которые  могут  иметь филиалы.
Листьям   дерева    соответствуют    преподаватели.    Выявить
преподавателей, ведущих занятия на трех и более кафедрах (10).

   8. Задано сильно ветвящееся дерево.  При  его  вводе  могли
быть  сделаны ошибки.  Провести проверку на отсутствие циклов,
то есть повторяющихся вершин.  При обнаружении цикла выдать на
экран последовательность вершин, составляющих цикл (10).

   9. Имеется план школьного сочинения,  записанный с  помощью
дерева.  Два друга решили написать сочинение вместе. Каждый из
них независимо  взял  несколько  частей,  задавая  их  корнями
соответствующих    поддеревьев.    Требуется    выдать    план
неохваченной части сочинения (10).

   10. Имеется   дерево,   корень    которого    соответствует
основателю  рода.  Сыновья  каждой  вершины  задают  сыновей и
дочерей  соответствующего  человека.  Указываются  имена  двух
человек  (например,  А  и  В).  Сообщить,  какая  из следующих
ситуаций имеет место:
   1) А предок В;
   2) В предок А;
   3) А и В имеют ближайшего общего предка С (10).

   11. В   некотором   институте   информация   об   имеющихся
компьютерах  задана   деревом.   Сыновьям   корневой   вершины 
соответствуют факультеты,  факультеты в  свою очередь  делятся
на  кафедры, кафедры  могут иметь в своем составе лаборатории. 
Компьютеры могут быть установлены в общих факультетских классах,
на кафедрах,  в  лабораториях  и идентифицируются  уникальными 
номерами. Требуется найти:
 1) факультеты с минимальным и максимальным числом компьютеров;
 2) кафедры с минимальным и максимальным числом компьютеров(11).

   12. В  листьях  бинарного  дерева  указаны   идентификаторы
переменных,  в других вершинах - знаки арифметических операций
или функции SIN,  COS, TG, CTG, LOG, EXP. Возможны одноместные
операции типа '+' или '-'. В этом случае требуется только один
операнд.    Значения    переменных     известны.     Проверить
синтаксическую  правильность идентификаторов.  Выдать на экран
выражение в инфиксной форме со скобками.  Определить  значение
выражения.
   Пример: ((-(((a1*bar)+c))-(((SIN(dors))-e)))) (11).
   
   13. Имеется  дерево  вызовов  процедур некоторой программы.
Структура программы такова,  что каждая  вызываемая  процедура
вложена в вызывающую ее процедуру. Задан объем памяти, который
требуется  для  загрузки  каждой  процедуры.  При  выходе   из
процедуры  занимаемая ей память освобождается.  Известно,  что
вызов процедур  при  работе  программы  соответствовал  обходу
дерева  в  порядке  сверху вниз.  Дать трассировку программы в
виде списка вызываемых процедур.  Процедура должна попадать  в
список, если к ней произошло обращение из вызывающей процедуры
либо возврат управления из вызванной ей  процедуры. Определить
размер  памяти,  необходимый  для работы программы,  и цепочку
вызовов, требующую максимальной памяти (11).

   14. Теннисный  турнир  проходит  по  олимпийской  системе с
выбываниями. В турнире участвуют 2^n игроков. Известен рейтинг
каждого игрока.  Результаты турнира записаны с помощью дерева.
Первоначально  задается  только  список  участников,   которым
соответствуют  листья  дерева.  Известно,  что турнир прошел в
полном соответствии с рейтингом игроков.  Требуется предложить
распределение  или посев сильнейших игроков так,  чтобы они не
встречались в начале турнира. Показать в наглядном виде дерево
проведенного турнира и выдать результаты по турам (12).

   15. В   некотором   институте   информация   об   имеющихся
компьютерах  задана двумя деревьями.  В первом из них сыновьям
корневой вершины соответствуют факультеты,  факультеты в  свою
очередь  делятся  на  кафедры,  кафедры  могут  иметь  в своем
составе лаборатории. Компьютеры могут быть установлены в общих
факультетских   классах,   на   кафедрах,   в  лабораториях  и
идентифицируются  уникальными  номерами.  Во   втором   дереве
сыновьям корня соответствуют учебные корпуса, корпуса включают
списки  аудиторий,  а  для  каждой  аудитории  заданы   номера
находящихся  в  них  компьютеров.  Некоторые  аудитории  могут
принадлежать  нескольким  факультетам.  Выдать  список   таких
аудиторий (12).

   16. Трассировка  программы,   не   содержащей   рекурсивных
вызовов  и  повторяющихся  имен  процедур,  распечатана в виде
списка выполняемых процедур. Процедура попадает в список, если
к ней произошло обращение из вызывающей процедуры либо возврат
управления из  вызванной  ей  процедуры.  Структура  программы
такова,  что  каждая вызываемая процедура вложена в вызывающую
ее процедуру.  Начало и  окончание  программы  должны  быть  в
головной процедуре.  Известен объем памяти,  который требуется
для  загрузки  каждой  процедуры.  При  выходе  из   процедуры
занимаемая ей память освобождается.  Построить и выдать дерево
вызовов процедур.  Определить размер памяти,  необходимый  для
работы  программы,  и цепочку вызовов,  требующую максимальной
памяти (12).

   17. Информация  о  файлах  на  жестких  дисках   компьютера
записана  с  помощью  дерева.  Обеспечить выполнение следующих
операций:
   1) загрузку дерева в память из файла;
   2) обход дерева папок в  режиме  диалога  (раскрыиме папок,
      подъем на уровень и т. П.); 
   3) Корректировку  дерева при создании новых папок и файлов,
их переименовании, копировании, переносе и удалении. 
   4) Сохранение дерева в файле (13).

   18. Имеется  некоторое  алгебраическое выражение.  Операнды
заданы идентификаторами,  операции выполняются по приоритетам,
допускается использование круглых скобок.  Требуется построить
и выдать в  наглядном  виде  бинарное  дерево,  представляющее
данное выражение (13).

   19. Имеется  И-ИЛИ   дерево,   соответствующее   некоторому
множеству  конструкций.  Требуется выдать на экран в наглядном
виде все элементы дерева (14).

   20. В  листьях  И-ИЛИ  дерева,  соответствующего некоторому
множеству  конструкций,  заданы   значения   массы.   Известно
максимально допустимое значение массы изделия. Требуется усечь
дерево   так,   чтобы   дерево    включало    все    элементы,
соответствующие  допустимым  значениям массы,  но не содержало
"лишних" вершин.  Конечное дерево выдать на экран в  наглядном
виде (14).

   21. Задано   И-ИЛИ   дерево,   соответствующее   некоторому
множеству изделий. Требуется:
   1) найти число изделий,  записанное с помощью этого дерева;
   2) если  число  изделий  больше  N,  организовать  усечение
дерева  в  диалоге,  спрашивая  пользователя,  какие   сыновья
ИЛИ-вершин отсекать и сообщая,  как при этом сокращается число
изделий.
   Если усекаются  все сыновья ИЛИ-вершины,  то отсекается она
сама и все поддерево,  висящее на сыне первой  ИЛИ-вершины  по
пути к корню дерева).
   УКАЗАНИЕ: если  корни   нескольких   поддеревьев   являются
сыновьями   И-вершины,   то   общее   число   элементов  равно
произведению  числа  элементов  поддеревьев,  а   если   корни
поддеревьев  -  сыновья ИЛИ-вершины,  то общее число элементов
находится как сумма числа элементов в поддеревьях.
   Начальное и  конечное  деревья  выдать на экран в наглядном
виде (14).

   22. Имеется   И-ИЛИ   дерево,   соответствующее  некоторому
множеству конструкций.  Конструктор  дает  два  списка  узлов:
желательных и нежелательных. Требуется:
   1) усечь   дерево   так,   чтобы   дерево   не    содержало
нежелательных  узлов  (вместе  с  вершиной  должно  отсекаться
поддерево,  висящее на сыне первой ИЛИ-вершины по пути к корню
дерева);
   2) выбрать на оставшемся дереве все элементы  с  наибольшим
количеством желательных узлов.
   Конечное дерево выдать на экран в наглядном виде (14).

   23. Теннисный  турнир  проходит  по  олимпийской  системе с
выбываниями.  Известен  рейтинг  каждого  игрока.   Результаты
турнира  записаны  с  помощью  дерева.  Первоначально задается
только список участников, которым соответствуют листья дерева.
Требуется  предложить  принцип  проведения  турнира (выбор пар
участников,  организация предварительных туров,  распределение
или  посев сильнейших игроков так,  чтобы они не встречались в
начале турнира и  т.П.),  Показать  в  наглядном  виде  дерево
проведенного  турнира,  выдать список сенсаций турнира,  когда
побеждал  игрок   с   низшим   рейтингом.   Определить   самый
сенсационный  результат по максимальной разнице рейтингов(14).

  24. В офисе  фирмы  Megasoft  установлены  N  компьютеров  с 
номерами от 1 до N, некоторые из них  соединены  между  собой. 
Сообщение между соединенными компьютерами проходит в любом  из 
двух направлений за 1 с. Компьютер,  получив  сообщение, сразу 
отправляет  его  всем  соединенным  с  ним  компьютерам.  Cеть 
устроена так, что между любыми двумя компьютерами  есть  путь, 
причем только один. Найти номера всех компьютеров,  с  которых 
главный программист Гилл Бейтс может отправить сообщение  так, 
чтобы максимальная задержка в  получении  сообщения  была  как 
можно меньше. 
  Ввод из файла INPUT.TXT. В первой строке вводится значение N 
(1<=N<=100). В каждой из следующих N-1  строк  вводится  через 
пробел пара номеров компьютеров, обозначающая соединение.
  Вывод в файл OUTPUT.TXT. В первой строке выводится количество
искомых компьютеров M. Во второй строке выдаются через пробел в
порядке возрастания номера искомых компьютеров.
  Пример
  Ввод
4
1 2
4 3
2 3
  Вывод
2
2 3
  Указание. Предложить структуру данных, обеспечивающую быстрое
нахождение листьев бескорневого дерева из условия задачи (15).

   25. В листьях  И-ИЛИ  дерева,  соответствующего  некоторому
множеству конструкций,  определены значения массы и стоимости.
Требуется на основе метода  ветвей  и  границ  найти  элементы
дерева,  масса  и  стоимость  которого  не  превышают заданных
максимально   допустимых   значений.   Обеспечить   сохранение
введенного дерева в файле и загрузку дерева из файла.
   УКАЗАНИЯ. Опишем возможные варианты  процедур  ветвления  и
отсечения метода ветвей и границ для данного случая.
   ПРОЦЕДУРА ВЕТВЛЕНИЯ.  Обходим И-ИЛИ дерево сверху  вниз.  В
каждой ИЛИ-вершине выбираем очередного сына, временно запрещая
остальных сыновей.
   ПРОЦЕДУРА ОТСЕЧЕНИЯ. После каждого ветвления дважды усекаем
текущее И-ИЛИ дерево по критериям массы и стоимости поочередно
так, чтобы
   1) дерево включало все элементы, соответствующие допустимым
значениям данного критерия;
   2) дерево не содержало "лишних" вершин, т.Е. Каждая вершина
дерева  входила  хотя бы в один элемент с допустимым значением
критерия.
   Если происходит   полное   усечение  дерева,  то  повторяем
процедуру  ветвления  в  последней  ИЛИ-вершине.  В  противном
случае продолжаем работу с усеченным И-ИЛИ деревом.
   Найденные элементы выдать на экран в наглядном виде (15).

                          2.4. Графы

   Общими требованиями к лабораторной работе являются:
   1) вводить  граф из файла в понятной для пользователя форме
(не в виде матрицы смежности, без дублирования информации и т.
П.);
   2) Обеспечить   возможность   многократных   запросов   без
повторного запуска программы.

   1. На плоскости заданы координаты N  элементов,  являющихся
выводами  печатной  платы.  Некоторые  элементы  связаны между
собой.  Требуется от элемента,  имеющего наибольшую  суммарную
длину   связей   с  другими  элементами,  построить  путь,  не
содержащий циклов.  При построении пути использовать следующее
правило:  из всех возможных элементов,  связанных с данным,  в
путь включается ближайший элемент (7).

   2. На плоскости заданы координаты N  элементов,  являющихся
выводами  печатной  платы.  Некоторые  элементы  связаны между
собой.  Требуется выбрать  начальный  элемент  для  построения
пути, не содержащего циклов, максимальной длины. Путь строится
по следующему правилу:  из всех возможных элементов, связанных
с данным, в путь включается ближайший элемент (7).

   3. На плоскости заданы координаты N  элементов,  являющихся
выводами  печатной  платы.  Некоторые  элементы  связаны между
собой.  Имеются два следующие правила для построения пути,  не
содержащего циклов:
   1) из всех возможных элементов,  связанных с данным, в путь
включается ближайший элемент;
   2) из всех возможных элементов,  связанных с данным, в путь
включается  элемент,  имеющий  наибольшее  число связей с теми
элементами, которые не состоят в пути.
   Сравнить эти правила по средней длине пути при всевозможных
начальных элементах (7).

   4. Имеется   сеть  железных  дорог,  связывающая  различные
города.  Города принадлежат  разным  суверенным  государствам.
Каждое государство взимает значительную пошлину за въезд в его
пределы.  В  некоторых  городах  берут  дополнительный  налог.
Требуется найти такой путь из пункта А в пункт В ,чтобы
   1) число   пересечений    государственных    границ    было
минимальным;
   2) среди путей,  удовлетворяющих первому условию, суммарный
налог был минимален (7).

   5. Имеется сеть автомобильных  дорог.  Известны  расстояния
всех   участков   дорог.   Некоторые  участки  аварийноопасны.
Требуется найти лучший путь из пункта  А  в  пункт  В.  Лучшим
считается путь,  имеющий в первую очередь наименьшую суммарную
протяженность аварийноопасных,  а во вторую очередь наименьшую
длину (7).

   6. В общежитии живет  N  студентов.  При  поселении  каждый
студент  представил список своих знакомых.  Каждое воскресение
организуется вечер знакомств,  когда знакомые любого  студента
знакомятся   между   собой.  Выяснить,  через  сколько  недель
познакомятся два указанных студента (8).

   7. Имеются  расписания вылетов самолетов в ряде аэропортов.
Требуется по начальному и конечному пунктам предложить маршрут
с  возможными пересадками,  оптимальный по одному из следующих
критериев:
   1) наименьшая суммарная стоимость билетов;
   2) минимальное число пересадок;
   3) наименьшее  время  в  пути,  включая  время  ожидания  в
аэропортах.
   При выборе маршрута считать,  что пересадка допустима, если
интервал времени между прилетом самолета и последующим вылетом
составляет не менее двух часов и не более суток (8).

   8. На плоскости имеются N  элементов,  являющихся  выводами
печатной   платы.  Некоторые  элементы  связаны  между  собой.
Требуется от элемента,  имеющего  наибольшее  число  связей  с
другими элементами,  построить путь, не содержащий циклов. При
построении  пути  использовать  следующее  правило:  из   всех
возможных  элементов,  связанных  с данным,  в путь включается
элемент,  который имеет наибольшее число продолжений из одного
или  двух  звеньев,  проходящих через элементы,  не вошедшие в
путь (8).

   9. Имеется  информация о торговых связях предпринимателей в
виде множества пар (A,B),  где A - продавец, а B - покупатель.
Покупатели  сами являются продавцами и перепродают закупленный
товар в соответствии со своими связями с наценкой 20  %. Задан
список    предпринимателей,    получивших   некоторый   товар.
Определить  такой  способ  получения  этого  товара  указанным
предпринимателем, чтобы наценка была минимальной (8).

   10. Имеется  план  электрической  схемы,  заданный  графом.
Вершинами  являются  места  соединений проводов.  Каждое ребро
характеризуется некоторым сопротивлением.  На одном  из  ребер
имеется   источник   питания.  Выявить  возможности  короткого
замыкания, когда находится замкнутая цепь, включающая источник
питания  и  имеющая  суммарное  сопротивление  ниже  заданного
порога (8).

   11. Список  членов  клуба  любителей  анекдотов  включает N
человек.  Каждый из членов клуба имеет  несколько  слушателей,
которым он рассказывает анекдоты.  В клубе действуют следующие
правила:
   1) если  один человек рассказывает другому неизвестный тому
анекдот, то он получает от клуба премию 1000 рублей;
   2) если  рассказанный  анекдот  оказывается  известным,  то
рассказчик платит клубу в качестве штрафа 1000 рублей;
   3) член клуба,  узнавший на некотором заседании клуба новый
анекдот обязан на следующем заседании  пересказать  его  своим
слушателям;
   4) на каждом заседании члены клуба с  меньшими  номерами  в
списке рассказывают новые анекдоты в первую очередь;
   5) каждый член клуба рассказывает анекдот любому  из  своих
слушателей не более одного раза.
   Член клуба с номером К узнал новый анекдот и  рассказал его
своим слушателям.  Определить, какую сумму должен получить или
выплатить в конце концов каждый член клуба (8).

   12. Имеется    сеть    автомобильных   дорог,   связывающих
населенные пункты некоторого района.  Известны длины  участков
дорог  между  пунктами.  В  M пунктах производят пряжу,  в N -
перерабатывают пряжу на фабриках, а в остальных пунктах нет ни
производства,  ни  переработки.  Решено закрыть K (K<N) фабрик
переработки,   наиболее   удаленных   от   источников   сырья.
Требуется:
   1) получить список пунктов, где закрываются фабрики;
   2) для каждой из оставшихся фабрик выдать S (S<M) ближайших
пунктов, где производят пряжу (8).

   13. Реализовать алгоритм построения транзитивного замыкания
Уоршела и проиллюстрировать по шагам этапы его выполнения (9).

   14. Проект  научно-технической  программы  задан  с помощью
ориентированного графа. Вершина графа соответствует отдельному
исследованию,   а   дуги   показывают  очередность  выполнения
исследований (каждое  исследование  может  начаться  не  ранее
окончания   предшествующих   исследований).  Продолжительность
каждого исследования известна.  Задан конечный срок выполнения
проекта.  Требуется  определить  максимальный интервал времени
для проведения каждого исследования,  чтобы  проект  мог  быть
завершен к назначенному сроку (9).

   15. Проект научно-технической  программы  задан  с  помощью
ориентированного графа. Вершина графа соответствует отдельному
исследованию,  а  дуги   показывают   очередность   выполнения
исследований  (каждое  исследование  может  начаться  не ранее
окончания  предшествующих   исследований).   Продолжительность
каждого исследования известна. Требуется:
   1) проверить граф на отсутствие циклов;
   2) найти  N  путей наибольшей трудоемкости,  где величину N
указывает пользователь.
   Путем считается  последовательность  работ,  которые должны
выполняться друг за  другом.  Трудоемкость  пути  -  суммарная
продолжительность работ на этом пути (9).

   16. Реализовать алгоритм поиска кратчайших путей  Флойда  и
проиллюстрировать по шагам этапы его выполнения (9).

   17. В космическом центре проектируется  система организации
связи   между  спутниками,  действующая  в  реальном  масштабе
времени.  Каждый  спутник  может  иметь  либо  не  иметь   как
радиостанцию,  так и приемник радиосигналов.  Сигналы с одного
спутника могут передаваться на другие через произвольное число
промежуточных спутников.  Заранее известно, когда два спутника
появляются в зоне радиовидимости и в  течение  какого  времени
спутники  будут  находиться в этой зоне.  Требуется определить
способы возможной связи между  двумя  заданными  спутниками  в
указанный   момент   времени   в   порядке  возрастания  числа
промежуточных звеньев (9).

   18. Реализовать алгоритм поиска кратчайших путей Дейкстры и
проиллюстрировать по шагам этапы его выполнения (10).

   19. Имеется  сеть  автомобильных  дорог.  Для каждой дороги
известна максимальная масса груза, которую можно  провезти  по 
этой   дороге.   С   помощью  алгоритма  Дейкстры   определить 
максимальный   груз,   который  можно  провести  между   двумя 
указанными городам (10).

   20. Имеются расписания вылетов самолетов в ряде аэропортов.
Требуется  по  начальному  и  конечному   пунктам   предложить
варианты   маршрута   с   возможными   пересадками  в  порядке
возрастания числа пересадок.  Для поиска вариантов реализовать
алгоритм поиска  в ширину. Проиллюстрировать этапы поиска(10).

   21. На диске имеется база  данных  по  физическим  эффектам
(ФЭ).  Каждый  ФЭ  записан в виде тройки компонент:  название,
входная  физическая  величина  (вход),   выходная   физическая
величина  (выход).  Имеется  не  более 50 различных физических
величин. Требуется построить в основной памяти граф связи ФЭ и
обеспечить  поиск  цепочек  ФЭ от одного до четырех звеньев по
заданным входу и выходу по возрастанию количества звеньев(11).

   22. В  файле  записаны  предложения по обмену жилплощадью в
пределах некоторого города, включающие пожелания по количеству
комнат,  наличию балкона и телефона.  Имеются варианты размена
одной квартиры на 2 других либо наоборот.  Требуется по заявке
клиента  предложить способы обмена.  Предусмотреть возможность
нахождения циклических обменов, в которых участвуют более двух
сторон.  Найденные варианты выдать в порядке возрастания числа
участвующих в обмене сторон.  Считать,  что клиентам  подходят
более хорошие по сравнению с их требованиями варианты переезда
(11).

   23. Имеется  информация о взаимных долгах предприятий. Если
имеется цепочка предприятий
     A1(a1) --> A2(a2) --> ... -->An(an) --> A1(a1),
где Ai - наименование предприятия,  а ai - размер долга,  то с
каждого из предприятий можно списать долг в размере min(ai), а
предприятие с минимальным долгом исключить из списка должников
следующему в цепочке  предприятию.  Требуется  найти  варианты
взаимного  списания  долгов. Предложить критерии оптимальности
и способы оптимизации (11).

   24. Имеется  сеть  автомобильных дорог.  Для каждой  дороги
известна ее длина. Один из городов является столицей. Требуется 
вывести список длин вторых по минимальности путей из столицы  в
другие города. Допускается  присутствие  циклических  путей.  В 
некоторые города вторых путей может не оказаться (12).

   25. Информация  о  некотором  изделии  задана   с   помощью
ориентированного графа.  Вершина графа соответствует отдельной
операции,  а дуги показывают очередность  выполнения  операций
(каждая   операция   может   начаться   не   ранее   окончания
предшествующих операций).  Продолжительность  каждой  операции
известна.  Имеется  один  станок  для  выполнения каждого типа
операций.  Если станок освобождается,  то производится  та  из
готовых  к выполнению операций,  для которой максимальный путь
от соответствующей вершины до конца  имеет  наибольшую  длину.
Определить  время  изготовления  изделия.  Выдать общий график
выполнения операций и график загрузки каждого станка (12).

              2.5. Поиск и сортировка данных

   1. Имеется массив элементов,  отсортированный по некоторому
полю. Методом бинарного поиска обеспечить:
   1) нахождение заданного элемента;
   2) вставку элемента;
   3) удаление элемента (8).

   2. Имеется   файл   записей  с  некоторым  ключевым  полем.
Построить  в  оперативной  памяти  идеально   сбалансированное
бинарное   дерево   поиска   и   обеспечить   поиск  указанных
записей (8).

   3. В текстовом файле задана последовательность целых чисел.
Отсортировать файл методом простого слияния с 3 лентами (8).

   4. В текстовом файле задана последовательность целых чисел.
Отсортировать файл методом простого слияния с 4 лентами (8).

   5. Показать этапы сортировки Шелла на примере массива целых
чисел (8).

   6. Сравнить по скорости рекурсивный и нерекурсивный варианты 
быстрой сортировки Хоара (8).

   7. Составить  программу  хеширования  массива с разрешением
коллизий методом цепочек. Обеспечить поиск и удаление записи с
заданным ключом (8).

   8. В файле записаны фамилии студентов и их анкетные данные.
Организовать  на  основе  хеширования  вспомогательный   файл,
обеспечивающий быстрый поиск информации по указанному студенту
(10).

   9. В файле имеется телефонный справочник,  включающий имена
владельцев телефонов.  Организовать быстрый поиск  по  номерам
телефонов   с   помощью   хеширования.  Обеспечить  дополнение
справочника (10).

   10. Имеется  текстовый  файл  записей  с некоторым ключевым
полем.  Отсортировать файл путем совмещения методов внутренней
и внешней сортировок (10).

   11. В   файле   имеется  информация   о   торговых   связях 
предпринимателей в виде множества пар (A,B), где A - продавец,
а B - покупатель. Общее число предпринимателей не  ограничено.
Часть продавцов являются производителями товаров, а  остальные
перепродают закупленный товар. По новому постановлению,  лица,
перепродающие  товары,  объявлены  спекулянтами.  Требуется на
основе  хеширования  обеспечить  быстрый  ответ   на   вопрос,
является ли указанный предприниматель  продавцом,  покупателем
или спекулянтом (11).

   12. Записи файла о неуспевающих студентах  имеют  следующую
структуру:
         --------------------------------------------
         ¦ Факультет ¦ Группа ¦ Фамилия   ¦ Число   ¦
         ¦           ¦        ¦ студента  ¦ хвостов ¦
         --------------------------------------------
     Файл частично отсортирован. Записи по каждому факультету,
а  также  по каждой группе расположены в файле друг за другом.
После пересдач экзаменов число хвостов у студентов  уменьшает-
ся. Требуется обеспечить коррекцию информации с помощью индек-
сирования.  Если студент выбывает из должников, пометить соот-
ветствующую запись специальным флагом.  Написать программу ко-
пирования файла с физическим удалением помеченных записей(11).

   13. Составить  программу  поиска  записи  c  включением   в
сбалансированном бинарном дереве поиска (АВЛ-дереве) (11).

   14. Имеется текстовый файл  записей  с  некоторым  ключевым
полем.  Отсортировать  файл методом многофазной сортировки с 3
лентами (11).

   15. Составить программу удаления записи из сбалансированного 
бинарного дерева поиска (АВЛ-дерева) (12).

   16. Составить  программу  поиска   записи  с  включением  в 
сильно ветвящемся Б-дереве порядка N (12).

   17. Составить   программу   удаления  записи   из    сильно 
ветвящегося Б-дерева порядка N (13).

   18. Составить   программу  поиска  записи  с  включением  в 
сильно   ветвящемся   Б-дереве   порядка   N. Б-дерево  должно 
храниться в файле с прямым доступом (13).

   19. Выполнить программную реализацию кэш-памяти  на  основе
хеширования  для чтения и записи блоков типизированного файла.
Проиллюстрировать механизм работы кэш-памяти (13).

   20. Имеется   телефонный   справочник   со   сведениями   о
владельцах  телефонов.  Организовать  индексацию  по   номерам
телефонов с помощью построения Б-дерева. Хранить дерево в виде
самостоятельного файла.  Обеспечить корректировку  информации.
Проиллюстрировать  этапы поиска информации по заданному номеру
телефона (15).


         3. ОФОРМЛЕНИЕ И ПОРЯДОК КОНТРОЛЯ РЕЗУЛЬТАТОВ

   Конечным результатом  выполнения каждой лабораторной работы
является отлаженная программа и набор тестов.  Текст программы
представляется  на   машинных   носителях  и  должен  включать 
постановку задачи, сведения об авторе и подробные комментарии.
   После выполнения    лабораторной    работы    преподаватель
проверяет   качество   оформления   текста   и    правильность
функционирования программы сначала на тестах автора, а затем и
на других данных.
   Преподаватель вправе   задать   вопросы   по   всем  частям
программы,  поэтому качественное документирование способствует
успешной защите работы.

                  4. ПРИМЕРЫ РЕШАЕМЫХ ЗАДАЧ

   В настоящем  разделе  описываются  пять  примеров  по темам
лабораторных работ.
   В примерах   не   ставилась   задача  обеспечения  удобного
интерфейса с пользователем.  Для этих целей можно  высвечивать
информацию  в  выделенных  на  экране  окнах,  в режиме "меню"
спрашивать  пользователя  о   его   намерениях,   организовать
начальную   заставку   с  информацией  о  программе,  добавить
элементы звукового сопровождения и т. П.

                     4.1. Текстовые файлы

   Дан текстовый файл,  в котором возможны  переносы  слов  со
строки  на  строку.  Подсчитать  общее  число слов.  Имя файла
задать в командной строке.

Program Word;
  Var
    f: text;              { исходный файл }
    name: string[20];     { для имени файла }
    s:    string;    { очередная строка файла }
    m,n,i,kol: integer;
    b: boolean;
  Procedure Soob(mess: string);
    Begin
      Writeln(mess);
      Readln;   { пауза }
      Halt      { конец }
    End;
  Begin  { основная программа }
    if ParamCount<1 then Soob('Не указан исходный файл')
      { в командной строке нет параметров }
    else Assign(f,ParamStr(1));
    name:=ParamStr(1);
    {$I-}     { отключение прерывания при ошибке ввода }
    Reset(f);
    {$I+}     { восстановление системной реакции на ошибку }
    if IoResult<>0 then Soob('Ошибка открытия файла '+name);
    kol:=0;

    While not eof(f) do
      begin
        Readln(f,s);
        m:=Length(s);  { длина  очередной строки }
        n:=1;   b:=true;
        While b do
          Begin
            While (s[n]=' ') and (n<=m) do n:=n+1;
              { пропуск пробелов }
            While (s[n]<>' ') and (n<=m) do n:=n+1;
              { очередное слово }
            if (s[n-1]<>'-') and (s[n-1]<>' ') and (m>0)
        { не пустая строка, нет переноса и пробелов в конце }
              then kol:=kol+1;
            if n>m then b:=false  { признак выхода из цикла }
          end
      end;
      Writeln('Количество слов ',kol);
      Readln        { заключительная пауза }
  End.

                     4.2. Линейные списки

   Составить программу    работы   с   циклической   очередью,
организованной с помощью структуры с  указателями.  Обеспечить
операции постановки в очередь,  продвижения очереди, вставки в
середину перед элементом  с  заданным  ключом  и  удаления  из
середины.

Program CiclList;
Uses crt;
Type  Ukaz = ^List;
      List = Record
               Key  : Integer;
               Next : Ukaz;
             End;
{      кольцевая очередь; указатели от начала к концу        }

{      конечный элемент замыкается на начало                 }
Var   p,q,r : Ukaz;  { r - указатель на конечный элемент     }
      Knew,k,tmp,CouElem : Integer;
{      CouElem - число элементов в очереди                   }
{------------------------------------------------------------}
{                   Постановка в очередь                     }
{------------------------------------------------------------}
Procedure MakeList;
Begin
  While True Do
    Begin
      Write('Ключ : ');
      ReadLn(Knew);
      If Knew = 0 Then
        Begin
          WriteLn('Всего элементов: ',CouElem);
          Exit
        End;
      New(q);
      If CouElem=0 Then
        q^.Next :=q   { первый элемент указывает сам на себя }
      Else
        Begin
          q^.Next:=r^.Next;     { r^.Next --> начало очереди }
          r^.Next := q      { связь с бывшим концом очереди  }
        End;
      q^.Key := Knew;
      r:=q;                  { новый элемент - конец очереди }
      Inc(CouElem);
    End
End;
{------------------------------------------------------------}
{                   Продвижение очереди                      }
{------------------------------------------------------------}
Procedure Go;
Var    Count : Integer;
Begin

  p:=r^.Next;                  { указатель на начало очереди }
  WriteLn('Ключ начальной позиции ',p^.Key);
  Dec(CouElem);
  If CouElem>0 Then
    begin
      q:=p^.Next;             { второй элемент }
      r^.Next:=q;
      WriteLn('Ключ новой начальной позиции ',q^.Key)
    end
  Else WriteLn('Очередь пуста');
  Dispose(p)
End;
{------------------------------------------------------------}
{    Вставка в середину перед элементом с заданным ключом    }
{------------------------------------------------------------}
Procedure IncList;
Var c : Integer;
    g : Ukaz;
Begin
  c:=0;
  Write('Перед элементом с ключом ');
  ReadLn(k);
  p:=r^.Next;                 { начало очереди }
  Repeat
    If p^.Key = k Then        { ищем элемент с нужным ключом }
      Begin
        New(g);               { и вставляем перед ним новый  }
        g^:=p^;
        p^.Next := g;
        Write('Ключ : ');
        ReadLn(Knew);
        If Knew = 0 Then Exit;
        p^.Key:=Knew;
        If c=CouElem-1 Then r:=g; {  вставка перед концом    }
        Inc(CouElem);
        Exit
      End

    Else
      Begin
         p := p^.Next;    {  продвинуться по очереди         }
         Inc(c)
      End
  Until c=CouElem;     { цикл до возврата в исходную позицию }
  WriteLn('В списке элемента с ключом ',k,' нет')
End;
{------------------------------------------------------------}
{              Удаление из середины очереди                  }
{------------------------------------------------------------}
Procedure DelFromList;
Var c :  Integer;
Begin
  c:=0;
  Write('С каким ключом ? ');
  ReadLn(k);
  p:=r^.Next;           { начало очереди }
  Repeat
    If p^.Key = k Then
      Begin                  { ищем элемент с нужным ключом  }
        If p = r^.Next Then Go { удаление из начала очереди  }
        Else
          Begin
            q^.Next := p^.Next;
            If p=r Then  r:=q;   {   конец очереди           }
            Dispose(p);
            Dec(CouElem);
          End;
        Exit
      End
    Else
      Begin
         q:=p;            {  запомнить предыдущий элемент   }
         p := p^.Next;    {  продвинуться по очереди        }
         Inc(c)
      End

  Until c=CouElem;    { цикл до возврата в исходную позицию }
  WriteLn('В списке элемента с ключом ',k,' нет')
End;

{------------------------------------------------------------}
{                Выдача очереди на экран                     }
{------------------------------------------------------------}
Procedure OutList;
Var Count,i : Integer;
Begin
  p:=r^.Next;                     { начало очереди }
  For i:=1 To CouElem Do
    begin
      Write(p^.Key,' ');
      p:=p^.Next
    end;
  WriteLn;
  WriteLn('Всего элементов: ',CouElem)
End;
{------------------------------------------------------------}
{                   Головная программа                       }
{------------------------------------------------------------}
Begin
  Clrscr;
  CouElem:=0;            { счетчик числа элементов в очереди }
  Repeat
    Writeln;
    WriteLn('1.Поставить в очередь (ключ 0-признак конца)');
    WriteLn('2.Продвинуть очередь');
    WriteLn('3.Вставить элемент');
    WriteLn('4.Удалить элемент');
    WriteLn('5.Показать всю очередь');
    WriteLn('6.Выход');
    Write('Выбираем : ');
    ReadLn(Tmp);         {  номер пункта меню }
    Case Tmp Of
      1 : MakeList;
      2 : If CouElem <> 0 Then Go
          Else WriteLn('Очереди нет, повторите выбор');
      3 : If CouElem <> 0 Then IncList
          Else WriteLn('Очереди нет, повторите выбор');
      4 : If CouElem <> 0 Then DelFromList
          Else WriteLn('Очереди нет, повторите выбор');
      5 : If CouElem <> 0 Then OutList
          Else WriteLn('Очередь пуста');
      6 : Halt
    End
  Until False
End.

                         4.3. Деревья

   В листьях    бинарного    дерева    указаны    цифры   либо
идентификаторы  переменных,  заданные   строчными   латинскими
буквами,  в  других  вершинах - знаки арифметических операций.
Значения переменных известны.  Выдать  на  экран  выражение  в
префиксной   и   постфиксной   формах.   Определить   значение
выражения.

Program TreeCount;
  Uses crt;
  Const
    zn= ['+','-','/','*','^'];
    let=['a'..'Z'];          { буквы }
    dig=['0'..'9'];          { Цифры }
    smv=zn+let+dig;          { допустимые символы при вводе }
  Type
    ukaz=^uzel;
    uzel=record              { структура вершины дерева }
           key:char ;        { знак, цифра или буква    }
           left,right:ukaz   { сыновья                  }
         end;
  Var
    root,kon:    ukaz;
    a:           array ['a'..'Z'] of real;
    { массив значений идентификаторов дерева }
    s:           set of char;  { множество введенных букв }
    n,k:         char;
  Procedure Sozd(t:ukaz);
    { рекурсивная процедура создания исходного дерева }
    { t-указатель на корень }
    Begin
      if t<>nil then
        begin
          Repeat
            Write('Введите значение вершины ');
            Readln(k);
            if not (k in smv) then
              Writeln('Неправильный символ, повторите ввод ');
          Until k in smv;
          t^.Key:=k;
          if not (k in zn) then  { k-буква или цифра }
            begin
              t^.Left:=nil;
              t^.Right:=nil;
              if k in let then   { k-буква }
                s:=s+[k]         { добавление в множество }
            end
          else
            begin
              Writeln('Переходим к левому сыну вершины ',
                       t^.Key);
              New(kon);
              t^.Left:=kon
            end;
          Sozd  (t^.Left);
          if t^.Left<>nil then   { t^.Key-буква или цифра }
            begin
              Writeln('Переходим к правому сыну вершины ',
                       t^.Key);
              New(kon);
              t^.Right:=kon
            end;
          Sozd(t^.Right)
        end
    End;
  Procedure PechPo(t:ukaz);
  { вывод на экран выражения в постфиксной форме }
  Begin
    if t<>nil then
      begin
        PechPo(t^.Left);
        PechPo(t^.Right);
        Write(t^.Key,' ')
      end
  End;
  Procedure PechPr(t:ukaz);
  { вывод на экран выражения в префиксной форме }
  Begin
    if t<>nil then
    begin
      Write(t^.Key,' ');
      PechPr(t^.Left);
      PechPr(t^.Right)
   end
  End;
  Function f1(t:ukaz):real;
  { расчет значения выражения, заданного бинарным деревом }
  Begin
    if t^.Left=nil then     { лист: в t^.Key цифра или буква }
      if t^.Key in dig then        { цифра }
        f1:=ord(t^.Key)-ord('0')   { числовое значение }
      else                         { буква-идентификатор }
        f1:=a[t^.Key]              { значение идентификатора }
    else case t^.Key of            { не лист: в t^.Key знак }
            '+': f1:=f1(t^.Left)+f1(t^.Right);
            '-': f1:=f1(t^.Left)-f1(t^.Right);
            '*': f1:=f1(t^.Left)*f1(t^.Right);
            '/': f1:=f1(t^.Left)/f1(t^.Right);
            '^': f1:=exp(f1(t^.Right)*ln(f1(t^.Left)))
         end
  End;
  Begin
    s:=[];          { пустое множество }
    Clrscr;
    New(root);
    Sozd  (root);
    Writeln('Ввод закончен !');
    Readln;   { пауза }
    PechPo(root);
    Writeln('   - постфиксная форма');
    Readln;
    PechPr(root);
    Writeln('   - префиксная форма');
    Readln;
    For n:='a' to 'z' do  { ввод значений идентификаторов }
      if n in s then
        begin
          Write (n,'=');
          Readln(a[n]);
        end;
    Writeln('Значение выражения:  ', f1(root):1:3);
    Readln
  End.

  .,.,.,.,,,, . H.E.L.L.O

                          4.4. Графы

   Имеется сеть междугородных  автомобильных  дорог.  Известны
расстояния  всех  участков  дорог.  Требуется  перечислить все
пути,  ведущие из пункта А в пункт  В,  не  проходящие  дважды
через один и тот же пункт.

Program Puti;
  { перечисление путей на графе }
  Uses crt;
  Const
    max=10;
  Type
    mat=array[1..Max,1..Max] of integer; { матрица смежности }
    put=1..Max;       { номер вершины в пути }
  Var
    matr : mat;
    m: set of put;    { множество вершин, входящих в путь }
    gr: array [1..Max] of integer; { текущий путь }
    a,b,versh,k,j,i: integer;
    l: boolean;
    ch: char;
  Procedure WwodMatr(var matr: mat);
    { ввод матрицы смежности }
    Begin
      TextBackGround(Black);
      TextColor(White);
      Clrscr;
      Write('Введите количество пунктов:  ');
      Readln(versh);
      For i:=1 to versh do
        For j:=1 to versh do
          begin
            matr[i,j]:=0;
            matr[j,i]:=0
          end;
      Repeat
        Write('Введите связи в виде пары вершин (99-конец) ');
        Read(i);
        if i<>99 then Read(j);
        if (i>0) and (i<=versh) and (j>0) and (j<=versh) then
          begin
            matr[i,j]:=1;
            matr[j,i]:=1   { матрица смежности симметрична }
          end
        else if i<>99 then Writeln('Ошибка ввода ')
      Until i=99;
      Writeln('Ввод закончен !');
      Writeln;
      Readln    { пауза }
    End;
  Procedure Wiwod(matr: mat);
    Begin
      Window(46,2,75,22);         { окно вывода результатов }
      TextBackGround(Cyan);
      Clrscr;
      TextColor(LightGreen);
      Write('  ');
      For i:=1 to versh do
        Write(i:2);               { номера столбцов матрицы }
      Writeln;
      For i:=1 to versh do
        begin
          TextColor(LightGreen);
          Write(i:2);             { номера строк матрицы }
          TextColor(White);
          For j:=1 to versh do
            Write(matr[i,j]:2);
          Writeln
        end
     End;
   Procedure PoiskPut(t: integer);
   { поиск всех путей на графе }
     Var i: integer;
     Begin
       gr[j]:=t; { добавление в путь текущей вершины }
       m:=m+[t]; { коррекция множества вершин пути   }
       j:=j+1;
       if t=b then  { b-конечная вершина }
         begin
           Write('Найден путь:  ');
           For i:=1 to j-1 do       { вывод пути }
             Write(gr[i],'  ');
           Writeln;
           Readln    { пауза }
         end
       else
         For i:=1 to versh do
           if not (i in m) and (matr[t,i]=1) then
    { поиск в глубину: выбор продолжения пути без цикла  }
             PoiskPut(i);
    { здесь оказываемся после нахождения очередного пути }
    { или в случае попадания в тупик                     }
       m:=m-[t];
    { исключение из множества вершин пути последней вершины }
       j:=j-1      { возврат в предыдущую вершину }
     End;
   Begin             { основная программа }
     Clrscr;         { очистка экрана     }
     WwodMatr(matr); { ввод матрицы смежности }
     l:=true;
     While l do
       begin
         Wiwod(matr);
         Writeln;
         Write('Введите исходный пункт A:  ');
         Readln(a);
         Write('Введите конечный пункт B:  ');
         Readln(b);
         Writeln;
         j:=1;
         m:=[];        { инициализация множества вершин пути }
         PoiskPut(a);  { перечисление всех путей             }
         Writeln('Путей больше нет ! ');
         Write('Повторить поиск[д/н] ? ');
         Readln(ch);
         if ch='н' then l:=false   { для выхода из цикла }
       end
   End.

                4.5. Поиск и сортировка данных

   Определить среднее   число   проб   при   поиске    записей
хешированного  массива  (квадратичная  проба) в зависимости от
коэффициента заполнения таблицы.

Program Heshirov;
Uses CRT;
Const
  M=977;        { простое число }
  M1=M-1;       {   M1=M-1      }
  LIM=500;      {   число попыток размещения в таблице }
  NUMTIME=20;   { число опытов }
Type
  field=record
          key:word;     { ключ размещаемой записи }
          flag:boolean  { TRUE - место в таблице свободно }
        end;
  tsize=0..M1;
  table=array [tsize] of field;
  result=array[ 0..100] Of real;
Var
  t:table;               { заполняемая таблица }
  h:tsize;               { индекс в таблице    }
  i,j,a,k,n: word;
  r:result;              { результаты по процентам }
Begin
  TextBackground(3);
  ClrScr;
  TextColor(14);
  TextBackground(0);
  GoToXY(35,3);
  Writeln('ХЕШИРОВАНИЕ');
  TextColor(11);                { цвет символов }
  TextBackground(0);            { цвет фона }
  GoToXY(6,4);
  Write('Зависимость числа квадратичных проб от коэффициента',
        ' заполнения таблицы');
  For a:=0 to 100 do
    r[a]:=0;
  For j:=1 to NUMTIME do
    begin
      n:=0;          { счетчик числа удачных размещений }
      For h:=0 to M1 do  { очистка таблицы }
        t[h].Flag:=TRUE;
      Randomize;   { случайная инициализация для Random }
      Repeat
        i:=0;
        k:=Random(64000);  { случайный ключ }
        h:=k mod M;        { приведение в диапазон 0-M1 }
        While not (t[h].Flag) and (t[h].Key<>k) and (i<LIM)) do
          { пока не найдено свободное место  }
          begin
            Inc(i);
            h:=(k+i*i)mod M
          end;
        if t[h].Key<>k then    { найдено свободное место }
           begin
             Inc(n);
             t[h].Key:=k;
             t[h].Flag:=FALSE  { признак заполнения }
           end;
        a:=Round(n/M*100);     { процент заполнения таблицы }
        r[a]:=(r[a]*(j-1)+i+1)/j
        { среднее число попыток для этого процента; здесь:   }
        { r[a]*(j-1) - общее число предыдущих попыток,       }
        { i+1 - число попыток при заполнении текущей таблицы }
      Until a>=95          { заполнение таблицы идет до 95 % }
    end;
    TextColor(13);
    TextBackground(1);
    GoToXY(1,10);               { начало строки 10 }
    { выдача рамки таблицы с результатами }
    Write('-');
    For i:=1 to 19 do
      if r[5*i]>10 then Write('----T')
      else Write('---T');
    Write(#8,'¬');     { #8 - возврат назад на 1 позицию }
    GoToXY(1,12);
    Write('+');
    For i:=1 to 19 do
      if r[5*i]>10 then Write('----+')
      else Write('---+');
    Write(#8,'+');
    GoToXY(1,11);
    Write('¦');
    GoToXY(1,13);
    Write('¦');
    { заполнение строки процентов (от 5 до 95 с шагом 5) }
    GoToXY(2,11);
    For i:=1 to 19 do
      if r[5*i]>10 then Write(' ',5*i:2,'%¦')
      else Write(5*i:2,'%¦');      { конечные результаты }
    GoToXY(2,13);
    For i:=1 to 19 do
      if r[5*i]>10 then Write(r[5*i]:4:1,'¦')
      else Write(r[5*i]:3:1,'¦');
    { завершение прорисовки рамки }
    GoToXY(1,14);
    Write('L');
    For i:=1 to 19 do
      if r[5*i]>10 then Write('----+')
      else Write('---+');
    Write(#8,'-');
    TextColor(10);
    TextBackground(4);
    GoToXY(4,23);
    Write('Press any key...');
    Repeat
    Until KeyPressed   { ожидание до нажатия клавиши }
  End.
